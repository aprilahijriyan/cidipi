#!/usr/bin/python

import json
import pathlib
from contextlib import suppress
from io import StringIO
from keyword import iskeyword
from typing import Any, Literal, Optional, TextIO

import humps
import orjson

MODULE_NAME = "cidipi"
PROTOCOL_DIR = "protocols"
PYTHON_MODULE_NAME = f"{MODULE_NAME}.{PROTOCOL_DIR}"
BASE_PATH = pathlib.Path(__file__).parent.parent
CDP_BASE_PATH = BASE_PATH / "devtools-protocol" / "json"
BROWSER_PROTOCOL_PATH = CDP_BASE_PATH / "browser_protocol.json"
JS_PROTOCOL_PATH = CDP_BASE_PATH / "js_protocol.json"
OUTPUT_PATH = BASE_PATH / MODULE_NAME / PROTOCOL_DIR
OUTPUT_PATH.mkdir(exist_ok=True)

HEADER_STRING = """# AUTO-GENERATED By cidipi/tools/generator.py. DO NOT EDIT.\n"""

OBJECT_MAPPING: dict[str, str] = {}
JSON_SCHEMA_TYPES = {
    "string": "str",
    "integer": "Union[float, int]",
    "number": "Union[float, int]",
    "boolean": "bool",
    "object": "dict[str, Any]",
    "array": "list[Any]",
    "any": "Any",
}


class Builder:
    def __init__(self, fp: TextIO, kind: Literal["command", "event", "type"]):
        self.fp = fp
        self.domain_object = None
        self.kind = kind
        self.buffer = StringIO()
        self.indent_size = 4
        self.current_indent = 0
        self.newline = "\n"
        self.initial_modules = set(
            [
                "from pydantic import BaseModel, PrivateAttr",
                "from typing import *",
                "from enum import Enum",
                "from cidipi.interface import ICommand, IEvent",
            ]
        )
        if kind != "type":
            self.initial_modules.add("import cidipi.protocols.types as types")

        self.import_modules = set()

    @property
    def domain(self):
        return self.domain_object["domain"]

    def write(self, s: str):
        indent = ""
        if self.current_indent > 0:
            indent = " " * self.current_indent
        self.buffer.write(indent + s)

    def writeln(self, s: str = ""):
        self.write(s + self.newline)

    def indent(self):
        self.current_indent += self.indent_size

    def dedent(self):
        self.current_indent -= self.indent_size

    def write_doc(self, s: str):
        if len(s) == 0:
            return
        doc_quote = '"""'
        self.writeln(doc_quote)
        self.writeln(s)
        self.writeln(doc_quote)

    def write_field(self, prop_object: dict[str, Any]):
        prop_name = prop_object["name"]
        prop_type = prop_object["type"]
        is_optional = prop_object.get("optional", False)
        prop_py_type = JSON_SCHEMA_TYPES[prop_type]
        if "enum" in prop_object:
            prop_py_type = f"Literal{json.dumps(prop_object['enum'])}"

        if prop_type == "array":
            # TODO: handle array type
            pass

        if is_optional:
            prop_py_type = f"Optional[{prop_py_type}] = None"

        expr = f"{prop_name}: {prop_py_type}"
        self.writeln(expr)

    def write_ref(self, prop_object: dict[str, Any]):
        prop_name = prop_object["name"]
        is_optional = prop_object.get("optional", False)
        ref: str = prop_object["$ref"]
        ref_parts = ref.split(".")
        is_submodule = len(ref_parts) > 1
        if not is_submodule:
            ref_parts.insert(0, self.domain)
        ref_parts[-1] = f"Type{humps.pascalize(ref_parts[-1])}"
        prefix = ["types"] if self.kind != "type" else []
        prop_py_type = serialize_ref(prefix + ref_parts)
        if is_optional:
            prop_py_type = f"Optional[{prop_py_type}] = None"
        self.writeln(f"{prop_name}: {prop_py_type}")
        # if is_submodule and self.kind != "type":
        #     sub_module = ref_parts[0]
        #     src_module = f"from {PYTHON_MODULE_NAME}.types import {sub_module}"
        #     self.import_modules.add(src_module)

    def write_type(self, type_object: dict[str, Any]):
        assert self.kind == "type", "write_type should only be called in type mode"
        type_id = "Type" + humps.pascalize(type_object["id"])
        type_desc = ""
        with suppress(KeyError):
            type_desc = type_object["description"]

        try:
            type_t = type_object["type"]
            py_type = JSON_SCHEMA_TYPES[type_t]
            if type_t == "string":
                if "enum" in type_object:
                    enum_members = type_object["enum"]
                    self.write(f"class {type_id}(str, Enum):")
                    self.writeln()
                    self.indent()
                    self.write_doc(type_desc)
                    for member in enum_members:
                        self.writeln(f"{serialize_var_name(member)} = '{member}'")
                    self.dedent()
                    self.writeln()
                else:
                    self.writeln(f"{type_id} = TypeVar('{type_id}', bound={py_type})")
                    self.write_doc(type_desc)

            elif type_t == "object":
                try:
                    properties = type_object["properties"]
                except KeyError:
                    self.writeln(f"{type_id} = TypeVar('{type_id}', bound={py_type})")
                    self.write_doc(type_desc)
                    self.writeln()
                    return

                self.write(f"class {type_id}(BaseModel):")
                self.writeln()
                self.indent()
                self.write_doc(type_desc)
                for prop_object in properties:
                    if "type" in prop_object:
                        self.write_field(prop_object)
                    elif "$ref" in prop_object:
                        self.write_ref(prop_object)
                    prop_desc = ""
                    with suppress(KeyError):
                        prop_desc = prop_object["description"]
                    self.write_doc(prop_desc)
                self.dedent()
                self.writeln()

            else:
                self.writeln(f"{type_id} = TypeVar('{type_id}', bound={py_type})")
                self.write_doc(type_desc)
                if type_t == "array":
                    # TODO: handle array type
                    pass

            self.writeln()
        except KeyError as e:
            raise RuntimeError(
                f"Cannot create type for id={type_id} (Error {e}) (File {self.fp.name})"
            ) from e

    def write_protocol(
        self,
        prot_object: dict[str, Any],
    ):
        assert self.kind in ["command", "event"], "Use self.write_type() instead"
        # prot_name = f"{self.kind.capitalize()}{humps.pascalize(prot_object['name'])}"
        prot_name = prot_object["name"]
        prot_desc = ""
        with suppress(KeyError):
            prot_desc = prot_object["description"]
        parameters = []
        with suppress(KeyError):
            parameters = prot_object["parameters"]

        base_klass = "ICommand" if self.kind == "command" else "IEvent"
        self.write(f"class {prot_name}({base_klass}):")
        self.writeln()
        self.indent()
        self.write_doc(prot_desc)
        self.writeln(f"_domain: str = PrivateAttr('{self.domain}')")
        for param_object in parameters:
            if "type" in param_object:
                self.write_field(param_object)
            elif "$ref" in param_object:
                self.write_ref(param_object)
            param_desc = ""
            with suppress(KeyError):
                param_desc = param_object["description"]
            self.write_doc(param_desc)
        self.dedent()
        self.writeln()

    write_command = write_protocol
    write_event = write_protocol

    def __enter__(self):
        print(">>> Domain:", self.domain)
        self.writeln(f"class {self.domain}:")
        self.indent()
        domain_desc = ""
        with suppress(KeyError):
            domain_desc = self.domain_object["description"]
        self.write_doc(domain_desc)
        self.writeln()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.dedent()
        self.writeln()
        print("<<< End of domain", self.domain)

    def save(self):
        module_stmt = "\n".join(self.initial_modules.union(self.import_modules))
        # if len(self.import_modules) > 0:
        #     module_stmt += "\n\nif TYPE_CHECKING:\n"
        #     module_stmt += "\n".join(map(lambda x: f"   {x}", self.import_modules))
        body = self.buffer.getvalue()
        data = f"\n{module_stmt}\n\n{body}"
        self.fp.write(data)
        self.fp.close()
        self.buffer = StringIO()
        self.import_modules.clear()


def serialize_ref(parts: list[str]):
    ref_src = ".".join(parts)
    return f"'{ref_src}'"


def serialize_var_name(s: str):
    if iskeyword(s.strip()):
        return s.upper()
    return humps.dekebabize(s)


def main():
    browser_protocol = orjson.loads(BROWSER_PROTOCOL_PATH.read_bytes())
    js_protocol = orjson.loads(JS_PROTOCOL_PATH.read_bytes())
    protocol_domains = js_protocol["domains"] + browser_protocol["domains"]
    with (OUTPUT_PATH / "__init__.py").open("w") as f:
        f.write(HEADER_STRING)
        browser_version = browser_protocol["version"]
        f.write(
            f"\n__cdp_version__ = '{browser_version['major']}.{browser_version['minor']}'\n\n"
        )

    def open_file(filename: str):
        # reset content of file
        with (OUTPUT_PATH / filename).open("w") as tmp:
            tmp.write("")

        # open file
        fp = (OUTPUT_PATH / filename).open("a")
        fp.write(HEADER_STRING)
        return fp

    types_builder: Optional[Builder] = None
    commands_builder: Optional[Builder] = None
    events_builder: Optional[Builder] = None

    processed_domains = []
    for domain_object in protocol_domains:
        domain_name: str = domain_object["domain"]
        if domain_name in processed_domains:
            print("Duplicate domain", domain_name)
            continue

        processed_domains.append(domain_name)
        if types_builder is None:
            types_builder = Builder(open_file("types.py"), kind="type")
        if commands_builder is None:
            commands_builder = Builder(open_file("commands.py"), kind="command")
        if events_builder is None:
            events_builder = Builder(open_file("events.py"), kind="event")

        if "types" in domain_object:
            types_builder.domain_object = domain_object
            with types_builder:
                types = domain_object["types"]
                for type_obj in types:
                    types_builder.write_type(type_obj)

        if "commands" in domain_object:
            commands_builder.domain_object = domain_object
            with commands_builder:
                commands = domain_object["commands"]
                for command_obj in commands:
                    commands_builder.write_command(command_obj)

        if "events" in domain_object:
            events_builder.domain_object = domain_object
            with events_builder:
                events = domain_object["events"]
                for event_obj in events:
                    events_builder.write_event(event_obj)

    types_builder.save()
    commands_builder.save()
    events_builder.save()


if __name__ == "__main__":
    main()
