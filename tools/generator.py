#!/usr/bin/python

import json
import pathlib
from contextlib import suppress
from io import StringIO
from keyword import iskeyword
from typing import Any, Optional, TextIO

import humps
import orjson
from loguru import logger

MODULE_NAME = "cidipi"
DOMAIN_DIR = "domains"
PYTHON_MODULE_NAME = f"{MODULE_NAME}.{DOMAIN_DIR}"
BASE_PATH = pathlib.Path(__file__).parent.parent
CDP_BASE_PATH = BASE_PATH / "devtools-protocol" / "json"
BROWSER_PROTOCOL_PATH = CDP_BASE_PATH / "browser_protocol.json"
JS_PROTOCOL_PATH = CDP_BASE_PATH / "js_protocol.json"
OUTPUT_PATH = BASE_PATH / MODULE_NAME / DOMAIN_DIR
OUTPUT_PATH.mkdir(exist_ok=True)

HEADER_STRING = """# AUTO-GENERATED By cidipi/tools/generator.py. DO NOT EDIT.\n"""

OBJECT_MAPPING: dict[str, str] = {}
JSON_SCHEMA_TYPES = {
    "string": "str",
    "integer": "Union[float, int]",
    "number": "Union[float, int]",
    "boolean": "bool",
    "object": "dict",
    "array": "list",
    "any": "Any",
}


class Builder:
    def __init__(self, fp: TextIO):
        self.fp = fp
        self.buffer = StringIO()
        self.indent_size = 4
        self.current_indent = 0
        self.newline = "\n"
        self.import_modules = set()

    def write(self, s: str):
        indent = ""
        if self.current_indent > 0:
            indent = " " * self.current_indent
        self.buffer.write(indent + s)

    def writeln(self, s: str = ""):
        self.write(s + self.newline)

    def indent(self):
        self.current_indent += self.indent_size

    def dedent(self):
        self.current_indent -= self.indent_size

    def save(self):
        module_stmt = "\n".join(self.import_modules)
        body = self.buffer.getvalue()
        data = f"{HEADER_STRING}\n{module_stmt}\n\n{body}"
        self.fp.write(data)
        self.buffer = StringIO()
        self.import_modules.clear()
        # print(data)


def serialize_ref(parts: list[str]):
    if len(parts) == 1:
        return f"'{parts[0]}'"
    last = parts.pop(-1)
    return ".".join(map(lambda x: x.lower(), parts)) + f".{last}"


def serialize_var_name(s: str):
    if iskeyword(s.strip()):
        return s.upper()
    return humps.dekebabize(s)


class PydanticBuilder(Builder):
    def __init__(self, fp: TextIO):
        super().__init__(fp)
        self.import_modules = set(
            [
                "from pydantic import BaseModel",
                "from typing import *",
                "from enum import Enum",
            ]
        )

    def write_doc(self, s: str):
        if len(s) == 0:
            return
        doc_quote = '"""'
        self.writeln(doc_quote)
        self.writeln(s)
        self.writeln(doc_quote)

    def write_field(self, prop_object: dict[str, Any]):
        prop_name = prop_object["name"]
        prop_type = prop_object["type"]
        is_optional = prop_object.get("optional", False)
        prop_py_type = JSON_SCHEMA_TYPES[prop_type]
        if "enum" in prop_object:
            prop_py_type = f"Literal{json.dumps(prop_object['enum'])}"

        if prop_type == "array":
            # TODO: handle array type
            pass

        if is_optional:
            prop_py_type = f"Optional[{prop_py_type}]"
        self.writeln(f"{prop_name}: {prop_py_type}")

    def write_ref(self, prop_object: dict[str, Any]):
        prop_name = prop_object["name"]
        is_optional = prop_object.get("optional", False)
        ref: str = prop_object["$ref"]
        ref_parts = ref.split(".")
        is_submodule = len(ref_parts) > 1
        prop_py_type = serialize_ref(ref_parts)
        if is_optional:
            prop_py_type = f"Optional[{prop_py_type}]"
        self.writeln(f"{prop_name}: {prop_py_type}")
        if is_submodule:
            sub_module = ref_parts[0].lower()
            src_module = f"from {PYTHON_MODULE_NAME} import {sub_module}"
            self.import_modules.add(src_module)

    def write_type(self, type_object: dict[str, Any]):
        type_id = type_object["id"]
        type_desc = ""
        with suppress(KeyError):
            type_desc = type_object["description"]

        try:
            type_t = type_object["type"]
            py_type = JSON_SCHEMA_TYPES[type_t]
            if type_t == "string":
                if "enum" in type_object:
                    enum_members = type_object["enum"]
                    self.write(f"class {type_id}(str, Enum):")
                    self.writeln()
                    self.indent()
                    self.write_doc(type_desc)
                    for member in enum_members:
                        self.writeln(f"{serialize_var_name(member)} = '{member}'")
                    self.dedent()
                    self.writeln()
                else:
                    self.writeln(f"{type_id} = TypeVar('{type_id}', bound={py_type})")
                    self.write_doc(type_desc)

            elif type_t == "object":
                try:
                    properties = type_object["properties"]
                except KeyError:
                    self.writeln(f"{type_id} = TypeVar('{type_id}', bound={py_type})")
                    self.write_doc(type_desc)
                    self.writeln()
                    return

                self.write(f"class {type_id}(BaseModel):")
                self.writeln()
                self.indent()
                self.write_doc(type_desc)
                for prop_object in properties:
                    if "type" in prop_object:
                        self.write_field(prop_object)
                    elif "$ref" in prop_object:
                        self.write_ref(prop_object)
                    prop_desc = ""
                    with suppress(KeyError):
                        prop_desc = prop_object["description"]
                    self.write_doc(prop_desc)
                self.dedent()
                self.writeln()

            else:
                self.writeln(f"{type_id} = TypeVar('{type_id}', bound={py_type})")
                self.write_doc(type_desc)
                if type_t == "array":
                    # TODO: handle array type
                    pass

            self.writeln()
        except KeyError as e:
            raise RuntimeError(
                f"Cannot create type for id={type_id} (Error {e}) (File {self.fp.name})"
            ) from e

    def write_protocol(
        self,
        prot_object: dict[str, Any],
        *,
        domain: str,
        has_types: Optional[bool] = False,
    ):
        prot_name = prot_object["name"]
        prot_desc = ""
        with suppress(KeyError):
            prot_desc = prot_object["description"]
        parameters = []
        with suppress(KeyError):
            parameters = prot_object["parameters"]

        self.write(f"class {prot_name}(BaseModel):")
        self.writeln()
        self.indent()
        self.write_doc(prot_desc)
        self.import_modules.add("from pydantic import PrivateAttr")
        if has_types:
            self.import_modules.add(
                f"from {PYTHON_MODULE_NAME}.{domain.lower()}.types import *"
            )
        self.writeln(f"__domain__: str = PrivateAttr('{domain}')")
        for param_object in parameters:
            if "type" in param_object:
                self.write_field(param_object)
            elif "$ref" in param_object:
                self.write_ref(param_object)
            param_desc = ""
            with suppress(KeyError):
                param_desc = param_object["description"]
            self.write_doc(param_desc)
        self.dedent()
        self.writeln()

    write_command = write_protocol
    write_event = write_protocol


def main():
    browser_protocol = orjson.loads(BROWSER_PROTOCOL_PATH.read_bytes())
    js_protocol = orjson.loads(JS_PROTOCOL_PATH.read_bytes())
    protocol_domains = js_protocol["domains"] + browser_protocol["domains"]
    with (OUTPUT_PATH / "__init__.py").open("w") as f:
        f.write(HEADER_STRING)
        browser_version = browser_protocol["version"]
        f.write(
            f"\n__cdp_version__ = '{browser_version['major']}.{browser_version['minor']}'\n\n"
        )

    for domain in protocol_domains:
        domain_name: str = domain["domain"].lower()
        domain_path = OUTPUT_PATH / domain_name
        logger.info(f"Generating {domain_path.name!r}...")
        domain_path.mkdir(exist_ok=True, parents=True)
        with (domain_path / "__init__.py").open("w") as init_fp:
            init_fp.write(HEADER_STRING)
            has_types = False
            if "types" in domain:
                has_types = True
                types = domain["types"]
                init_fp.write(
                    f"from {PYTHON_MODULE_NAME}.{domain_name}.types import *\n"
                )
                with (domain_path / "types.py").open("w") as types_fp:
                    logger.debug(f"Generating [{len(types)}] {types_fp.name!r}...")
                    builder = PydanticBuilder(types_fp)
                    for type_ in types:
                        type_id: str = type_["id"]
                        logger.debug(f"Generating type {type_id!r}...")
                        builder.write_type(type_)
                    builder.save()

            if "commands" in domain:
                commands = domain["commands"]
                init_fp.write(
                    f"from {PYTHON_MODULE_NAME}.{domain_name}.commands import *\n"
                )
                with (domain_path / "commands.py").open("w") as cmd_fp:
                    logger.info(f"Generating {cmd_fp.name!r}...")
                    builder = PydanticBuilder(cmd_fp)
                    for command in commands:
                        command_name: str = command["name"]
                        logger.debug(f"Generating command {command_name!r}...")
                        builder.write_command(
                            command, domain=domain["domain"], has_types=has_types
                        )
                    builder.save()

            if "events" in domain:
                events = domain["events"]
                init_fp.write(
                    f"from {PYTHON_MODULE_NAME}.{domain_name}.events import *\n"
                )
                with (domain_path / "events.py").open("w") as event_fp:
                    logger.info(f"Generating {event_fp.name!r}...")
                    builder = PydanticBuilder(event_fp)
                    for event in events:
                        event_name: str = event["name"]
                        logger.debug(f"Generating event {event_name!r}...")
                        builder.write_event(
                            event, domain=domain["domain"], has_types=has_types
                        )
                    builder.save()


if __name__ == "__main__":
    main()
