# AUTO-GENERATED By cidipi/tools/generator.py. DO NOT EDIT.

from enum import Enum
from typing import Literal, Optional, TypeVar, Union

from pydantic import BaseModel

from cidipi import io, network, runtime, security


class ResourceType(str, Enum):
    """
    Resource type as it was perceived by the rendering engine.
    """

    Document = "Document"
    Stylesheet = "Stylesheet"
    Image = "Image"
    Media = "Media"
    Font = "Font"
    Script = "Script"
    TextTrack = "TextTrack"
    XHR = "XHR"
    Fetch = "Fetch"
    Prefetch = "Prefetch"
    EventSource = "EventSource"
    WebSocket = "WebSocket"
    Manifest = "Manifest"
    SignedExchange = "SignedExchange"
    Ping = "Ping"
    CSPViolationReport = "CSPViolationReport"
    Preflight = "Preflight"
    Other = "Other"


LoaderId = TypeVar("LoaderId", bound=str)
"""
Unique loader identifier.
"""

RequestId = TypeVar("RequestId", bound=str)
"""
Unique request identifier.
"""

InterceptionId = TypeVar("InterceptionId", bound=str)
"""
Unique intercepted request identifier.
"""


class ErrorReason(str, Enum):
    """
    Network level fetch failure reason.
    """

    Failed = "Failed"
    Aborted = "Aborted"
    TimedOut = "TimedOut"
    AccessDenied = "AccessDenied"
    ConnectionClosed = "ConnectionClosed"
    ConnectionReset = "ConnectionReset"
    ConnectionRefused = "ConnectionRefused"
    ConnectionAborted = "ConnectionAborted"
    ConnectionFailed = "ConnectionFailed"
    NameNotResolved = "NameNotResolved"
    InternetDisconnected = "InternetDisconnected"
    AddressUnreachable = "AddressUnreachable"
    BlockedByClient = "BlockedByClient"
    BlockedByResponse = "BlockedByResponse"


TimeSinceEpoch = TypeVar("TimeSinceEpoch", bound=Union[float, int])
"""
UTC time in seconds, counted from January 1, 1970.
"""

MonotonicTime = TypeVar("MonotonicTime", bound=Union[float, int])
"""
Monotonically increasing time in seconds since an arbitrary point in the past.
"""

Headers = TypeVar("Headers", bound=dict)
"""
Request / response headers as keys / values of JSON object.
"""


class ConnectionType(str, Enum):
    """
    The underlying connection technology that the browser is supposedly using.
    """

    none = "none"
    cellular2g = "cellular2g"
    cellular3g = "cellular3g"
    cellular4g = "cellular4g"
    bluetooth = "bluetooth"
    ethernet = "ethernet"
    wifi = "wifi"
    wimax = "wimax"
    other = "other"


class CookieSameSite(str, Enum):
    """
        Represents the cookie's 'SameSite' status:
    https://tools.ietf.org/html/draft-west-first-party-cookies
    """

    Strict = "Strict"
    Lax = "Lax"
    NONE = "None"


class CookiePriority(str, Enum):
    """
        Represents the cookie's 'Priority' status:
    https://tools.ietf.org/html/draft-west-cookie-priority-00
    """

    Low = "Low"
    Medium = "Medium"
    High = "High"


class CookieSourceScheme(str, Enum):
    """
        Represents the source scheme of the origin that originally set the cookie.
    A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme.
    This is a temporary ability and it will be removed in the future.
    """

    Unset = "Unset"
    NonSecure = "NonSecure"
    Secure = "Secure"


class ResourceTiming(BaseModel):
    """
    Timing information for the request.
    """

    requestTime: Union[float, int]
    """
    Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
milliseconds relatively to this requestTime.
    """
    proxyStart: Union[float, int]
    """
    Started resolving proxy.
    """
    proxyEnd: Union[float, int]
    """
    Finished resolving proxy.
    """
    dnsStart: Union[float, int]
    """
    Started DNS address resolve.
    """
    dnsEnd: Union[float, int]
    """
    Finished DNS address resolve.
    """
    connectStart: Union[float, int]
    """
    Started connecting to the remote host.
    """
    connectEnd: Union[float, int]
    """
    Connected to the remote host.
    """
    sslStart: Union[float, int]
    """
    Started SSL handshake.
    """
    sslEnd: Union[float, int]
    """
    Finished SSL handshake.
    """
    workerStart: Union[float, int]
    """
    Started running ServiceWorker.
    """
    workerReady: Union[float, int]
    """
    Finished Starting ServiceWorker.
    """
    workerFetchStart: Union[float, int]
    """
    Started fetch event.
    """
    workerRespondWithSettled: Union[float, int]
    """
    Settled fetch event respondWith promise.
    """
    workerRouterEvaluationStart: Optional[Union[float, int]]
    """
    Started ServiceWorker static routing source evaluation.
    """
    workerCacheLookupStart: Optional[Union[float, int]]
    """
    Started cache lookup when the source was evaluated to `cache`.
    """
    sendStart: Union[float, int]
    """
    Started sending request.
    """
    sendEnd: Union[float, int]
    """
    Finished sending request.
    """
    pushStart: Union[float, int]
    """
    Time the server started pushing request.
    """
    pushEnd: Union[float, int]
    """
    Time the server finished pushing request.
    """
    receiveHeadersStart: Union[float, int]
    """
    Started receiving response headers.
    """
    receiveHeadersEnd: Union[float, int]
    """
    Finished receiving response headers.
    """


class ResourcePriority(str, Enum):
    """
    Loading priority of a resource request.
    """

    VeryLow = "VeryLow"
    Low = "Low"
    Medium = "Medium"
    High = "High"
    VeryHigh = "VeryHigh"


class PostDataEntry(BaseModel):
    """
    Post data entry for HTTP request
    """

    bytes: Optional[str]


class Request(BaseModel):
    """
    HTTP request data.
    """

    url: str
    """
    Request URL (without fragment).
    """
    urlFragment: Optional[str]
    """
    Fragment of the requested URL starting with hash, if present.
    """
    method: str
    """
    HTTP request method.
    """
    headers: "Headers"
    """
    HTTP request headers.
    """
    postData: Optional[str]
    """
    HTTP POST request data.
Use postDataEntries instead.
    """
    hasPostData: Optional[bool]
    """
    True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
    """
    postDataEntries: Optional[list]
    """
    Request body elements (post data broken into individual entries).
    """
    mixedContentType: Optional[security.MixedContentType]
    """
    The mixed content type of the request.
    """
    initialPriority: "ResourcePriority"
    """
    Priority of the resource request at the time request is sent.
    """
    referrerPolicy: Literal[
        "unsafe-url",
        "no-referrer-when-downgrade",
        "no-referrer",
        "origin",
        "origin-when-cross-origin",
        "same-origin",
        "strict-origin",
        "strict-origin-when-cross-origin",
    ]
    """
    The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
    """
    isLinkPreload: Optional[bool]
    """
    Whether is loaded via link preload.
    """
    trustTokenParams: Optional["TrustTokenParams"]
    """
    Set for requests when the TrustToken API is used. Contains the parameters
passed by the developer (e.g. via "fetch") as understood by the backend.
    """
    isSameSite: Optional[bool]
    """
    True if this resource request is considered to be the 'same site' as the
request corresponding to the main frame.
    """


class SignedCertificateTimestamp(BaseModel):
    """
    Details of a signed certificate timestamp (SCT).
    """

    status: str
    """
    Validation status.
    """
    origin: str
    """
    Origin.
    """
    logDescription: str
    """
    Log name / description.
    """
    logId: str
    """
    Log ID.
    """
    timestamp: Union[float, int]
    """
    Issuance date. Unlike TimeSinceEpoch, this contains the number of
milliseconds since January 1, 1970, UTC, not the number of seconds.
    """
    hashAlgorithm: str
    """
    Hash algorithm.
    """
    signatureAlgorithm: str
    """
    Signature algorithm.
    """
    signatureData: str
    """
    Signature data.
    """


class SecurityDetails(BaseModel):
    """
    Security details about a request.
    """

    protocol: str
    """
    Protocol name (e.g. "TLS 1.2" or "QUIC").
    """
    keyExchange: str
    """
    Key Exchange used by the connection, or the empty string if not applicable.
    """
    keyExchangeGroup: Optional[str]
    """
    (EC)DH group used by the connection, if applicable.
    """
    cipher: str
    """
    Cipher name.
    """
    mac: Optional[str]
    """
    TLS MAC. Note that AEAD ciphers do not have separate MACs.
    """
    certificateId: security.CertificateId
    """
    Certificate ID value.
    """
    subjectName: str
    """
    Certificate subject name.
    """
    sanList: list
    """
    Subject Alternative Name (SAN) DNS names and IP addresses.
    """
    issuer: str
    """
    Name of the issuing CA.
    """
    validFrom: "TimeSinceEpoch"
    """
    Certificate valid from date.
    """
    validTo: "TimeSinceEpoch"
    """
    Certificate valid to (expiration) date
    """
    signedCertificateTimestampList: list
    """
    List of signed certificate timestamps (SCTs).
    """
    certificateTransparencyCompliance: "CertificateTransparencyCompliance"
    """
    Whether the request complied with Certificate Transparency policy
    """
    serverSignatureAlgorithm: Optional[Union[float, int]]
    """
    The signature algorithm used by the server in the TLS server signature,
represented as a TLS SignatureScheme code point. Omitted if not
applicable or not known.
    """
    encryptedClientHello: bool
    """
    Whether the connection used Encrypted ClientHello
    """


class CertificateTransparencyCompliance(str, Enum):
    """
    Whether the request complied with Certificate Transparency policy.
    """

    unknown = "unknown"
    not_compliant = "not-compliant"
    compliant = "compliant"


class BlockedReason(str, Enum):
    """
    The reason why request was blocked.
    """

    other = "other"
    csp = "csp"
    mixed_content = "mixed-content"
    origin = "origin"
    inspector = "inspector"
    subresource_filter = "subresource-filter"
    content_type = "content-type"
    coep_frame_resource_needs_coep_header = "coep-frame-resource-needs-coep-header"
    coop_sandboxed_iframe_cannot_navigate_to_coop_page = (
        "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
    )
    corp_not_same_origin = "corp-not-same-origin"
    corp_not_same_origin_after_defaulted_to_same_origin_by_coep = (
        "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
    )
    corp_not_same_origin_after_defaulted_to_same_origin_by_dip = (
        "corp-not-same-origin-after-defaulted-to-same-origin-by-dip"
    )
    corp_not_same_origin_after_defaulted_to_same_origin_by_coep_and_dip = (
        "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip"
    )
    corp_not_same_site = "corp-not-same-site"


class CorsError(str, Enum):
    """
    The reason why request was blocked.
    """

    DisallowedByMode = "DisallowedByMode"
    InvalidResponse = "InvalidResponse"
    WildcardOriginNotAllowed = "WildcardOriginNotAllowed"
    MissingAllowOriginHeader = "MissingAllowOriginHeader"
    MultipleAllowOriginValues = "MultipleAllowOriginValues"
    InvalidAllowOriginValue = "InvalidAllowOriginValue"
    AllowOriginMismatch = "AllowOriginMismatch"
    InvalidAllowCredentials = "InvalidAllowCredentials"
    CorsDisabledScheme = "CorsDisabledScheme"
    PreflightInvalidStatus = "PreflightInvalidStatus"
    PreflightDisallowedRedirect = "PreflightDisallowedRedirect"
    PreflightWildcardOriginNotAllowed = "PreflightWildcardOriginNotAllowed"
    PreflightMissingAllowOriginHeader = "PreflightMissingAllowOriginHeader"
    PreflightMultipleAllowOriginValues = "PreflightMultipleAllowOriginValues"
    PreflightInvalidAllowOriginValue = "PreflightInvalidAllowOriginValue"
    PreflightAllowOriginMismatch = "PreflightAllowOriginMismatch"
    PreflightInvalidAllowCredentials = "PreflightInvalidAllowCredentials"
    PreflightMissingAllowExternal = "PreflightMissingAllowExternal"
    PreflightInvalidAllowExternal = "PreflightInvalidAllowExternal"
    PreflightMissingAllowPrivateNetwork = "PreflightMissingAllowPrivateNetwork"
    PreflightInvalidAllowPrivateNetwork = "PreflightInvalidAllowPrivateNetwork"
    InvalidAllowMethodsPreflightResponse = "InvalidAllowMethodsPreflightResponse"
    InvalidAllowHeadersPreflightResponse = "InvalidAllowHeadersPreflightResponse"
    MethodDisallowedByPreflightResponse = "MethodDisallowedByPreflightResponse"
    HeaderDisallowedByPreflightResponse = "HeaderDisallowedByPreflightResponse"
    RedirectContainsCredentials = "RedirectContainsCredentials"
    InsecurePrivateNetwork = "InsecurePrivateNetwork"
    InvalidPrivateNetworkAccess = "InvalidPrivateNetworkAccess"
    UnexpectedPrivateNetworkAccess = "UnexpectedPrivateNetworkAccess"
    NoCorsRedirectModeNotFollow = "NoCorsRedirectModeNotFollow"
    PreflightMissingPrivateNetworkAccessId = "PreflightMissingPrivateNetworkAccessId"
    PreflightMissingPrivateNetworkAccessName = (
        "PreflightMissingPrivateNetworkAccessName"
    )
    PrivateNetworkAccessPermissionUnavailable = (
        "PrivateNetworkAccessPermissionUnavailable"
    )
    PrivateNetworkAccessPermissionDenied = "PrivateNetworkAccessPermissionDenied"


class CorsErrorStatus(BaseModel):
    corsError: "CorsError"
    failedParameter: str


class ServiceWorkerResponseSource(str, Enum):
    """
    Source of serviceworker response.
    """

    cache_storage = "cache-storage"
    http_cache = "http-cache"
    fallback_code = "fallback-code"
    network = "network"


class TrustTokenParams(BaseModel):
    """
        Determines what type of Trust Token operation is executed and
    depending on the type, some additional parameters. The values
    are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
    """

    operation: "TrustTokenOperationType"
    refreshPolicy: Literal["UseCached", "Refresh"]
    """
    Only set for "token-redemption" operation and determine whether
to request a fresh SRR or use a still valid cached SRR.
    """
    issuers: Optional[list]
    """
    Origins of issuers from whom to request tokens or redemption
records.
    """


class TrustTokenOperationType(str, Enum):
    Issuance = "Issuance"
    Redemption = "Redemption"
    Signing = "Signing"


class AlternateProtocolUsage(str, Enum):
    """
    The reason why Chrome uses a specific transport protocol for HTTP semantics.
    """

    alternativeJobWonWithoutRace = "alternativeJobWonWithoutRace"
    alternativeJobWonRace = "alternativeJobWonRace"
    mainJobWonRace = "mainJobWonRace"
    mappingMissing = "mappingMissing"
    broken = "broken"
    dnsAlpnH3JobWonWithoutRace = "dnsAlpnH3JobWonWithoutRace"
    dnsAlpnH3JobWonRace = "dnsAlpnH3JobWonRace"
    unspecifiedReason = "unspecifiedReason"


class ServiceWorkerRouterSource(str, Enum):
    """
    Source of service worker router.
    """

    network = "network"
    cache = "cache"
    fetch_event = "fetch-event"
    race_network_and_fetch_handler = "race-network-and-fetch-handler"


class ServiceWorkerRouterInfo(BaseModel):
    ruleIdMatched: Optional[Union[float, int]]
    """
    ID of the rule matched. If there is a matched rule, this field will
be set, otherwiser no value will be set.
    """
    matchedSourceType: Optional["ServiceWorkerRouterSource"]
    """
    The router source of the matched rule. If there is a matched rule, this
field will be set, otherwise no value will be set.
    """
    actualSourceType: Optional["ServiceWorkerRouterSource"]
    """
    The actual router source used.
    """


class Response(BaseModel):
    """
    HTTP response data.
    """

    url: str
    """
    Response URL. This URL can be different from CachedResource.url in case of redirect.
    """
    status: Union[float, int]
    """
    HTTP response status code.
    """
    statusText: str
    """
    HTTP response status text.
    """
    headers: "Headers"
    """
    HTTP response headers.
    """
    headersText: Optional[str]
    """
    HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
    """
    mimeType: str
    """
    Resource mimeType as determined by the browser.
    """
    charset: str
    """
    Resource charset as determined by the browser (if applicable).
    """
    requestHeaders: Optional["Headers"]
    """
    Refined HTTP request headers that were actually transmitted over the network.
    """
    requestHeadersText: Optional[str]
    """
    HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
    """
    connectionReused: bool
    """
    Specifies whether physical connection was actually reused for this request.
    """
    connectionId: Union[float, int]
    """
    Physical connection id that was actually used for this request.
    """
    remoteIPAddress: Optional[str]
    """
    Remote IP address.
    """
    remotePort: Optional[Union[float, int]]
    """
    Remote port.
    """
    fromDiskCache: Optional[bool]
    """
    Specifies that the request was served from the disk cache.
    """
    fromServiceWorker: Optional[bool]
    """
    Specifies that the request was served from the ServiceWorker.
    """
    fromPrefetchCache: Optional[bool]
    """
    Specifies that the request was served from the prefetch cache.
    """
    fromEarlyHints: Optional[bool]
    """
    Specifies that the request was served from the prefetch cache.
    """
    serviceWorkerRouterInfo: Optional["ServiceWorkerRouterInfo"]
    """
    Information about how ServiceWorker Static Router API was used. If this
field is set with `matchedSourceType` field, a matching rule is found.
If this field is set without `matchedSource`, no matching rule is found.
Otherwise, the API is not used.
    """
    encodedDataLength: Union[float, int]
    """
    Total number of bytes received for this request so far.
    """
    timing: Optional["ResourceTiming"]
    """
    Timing information for the given request.
    """
    serviceWorkerResponseSource: Optional["ServiceWorkerResponseSource"]
    """
    Response source of response from ServiceWorker.
    """
    responseTime: Optional["TimeSinceEpoch"]
    """
    The time at which the returned response was generated.
    """
    cacheStorageCacheName: Optional[str]
    """
    Cache Storage Cache Name.
    """
    protocol: Optional[str]
    """
    Protocol used to fetch this request.
    """
    alternateProtocolUsage: Optional["AlternateProtocolUsage"]
    """
    The reason why Chrome uses a specific transport protocol for HTTP semantics.
    """
    securityState: security.SecurityState
    """
    Security state of the request resource.
    """
    securityDetails: Optional["SecurityDetails"]
    """
    Security details for the request.
    """


class WebSocketRequest(BaseModel):
    """
    WebSocket request data.
    """

    headers: "Headers"
    """
    HTTP request headers.
    """


class WebSocketResponse(BaseModel):
    """
    WebSocket response data.
    """

    status: Union[float, int]
    """
    HTTP response status code.
    """
    statusText: str
    """
    HTTP response status text.
    """
    headers: "Headers"
    """
    HTTP response headers.
    """
    headersText: Optional[str]
    """
    HTTP response headers text.
    """
    requestHeaders: Optional["Headers"]
    """
    HTTP request headers.
    """
    requestHeadersText: Optional[str]
    """
    HTTP request headers text.
    """


class WebSocketFrame(BaseModel):
    """
    WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
    """

    opcode: Union[float, int]
    """
    WebSocket message opcode.
    """
    mask: bool
    """
    WebSocket message mask.
    """
    payloadData: str
    """
    WebSocket message payload data.
If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
    """


class CachedResource(BaseModel):
    """
    Information about the cached resource.
    """

    url: str
    """
    Resource URL. This is the url of the original network request.
    """
    type: "ResourceType"
    """
    Type of this resource.
    """
    response: Optional["Response"]
    """
    Cached response data.
    """
    bodySize: Union[float, int]
    """
    Cached response body size.
    """


class Initiator(BaseModel):
    """
    Information about the request initiator.
    """

    type: Literal["parser", "script", "preload", "SignedExchange", "preflight", "other"]
    """
    Type of this initiator.
    """
    stack: Optional[runtime.StackTrace]
    """
    Initiator JavaScript stack trace, set for Script only.
    """
    url: Optional[str]
    """
    Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
    """
    lineNumber: Optional[Union[float, int]]
    """
    Initiator line number, set for Parser type or for Script type (when script is importing
module) (0-based).
    """
    columnNumber: Optional[Union[float, int]]
    """
    Initiator column number, set for Parser type or for Script type (when script is importing
module) (0-based).
    """
    requestId: Optional["RequestId"]
    """
    Set if another request triggered this request (e.g. preflight).
    """


class CookiePartitionKey(BaseModel):
    """
        cookiePartitionKey object
    The representation of the components of the key that are created by the cookiePartitionKey class contained in net/cookies/cookie_partition_key.h.
    """

    topLevelSite: str
    """
    The site of the top-level URL the browser was visiting at the start
of the request to the endpoint that set the cookie.
    """
    hasCrossSiteAncestor: bool
    """
    Indicates if the cookie has any ancestors that are cross-site to the topLevelSite.
    """


class Cookie(BaseModel):
    """
    Cookie object
    """

    name: str
    """
    Cookie name.
    """
    value: str
    """
    Cookie value.
    """
    domain: str
    """
    Cookie domain.
    """
    path: str
    """
    Cookie path.
    """
    expires: Union[float, int]
    """
    Cookie expiration date as the number of seconds since the UNIX epoch.
    """
    size: Union[float, int]
    """
    Cookie size.
    """
    httpOnly: bool
    """
    True if cookie is http-only.
    """
    secure: bool
    """
    True if cookie is secure.
    """
    session: bool
    """
    True in case of session cookie.
    """
    sameSite: Optional["CookieSameSite"]
    """
    Cookie SameSite type.
    """
    priority: "CookiePriority"
    """
    Cookie Priority
    """
    sameParty: bool
    """
    True if cookie is SameParty.
    """
    sourceScheme: "CookieSourceScheme"
    """
    Cookie source scheme type.
    """
    sourcePort: Union[float, int]
    """
    Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
This is a temporary ability and it will be removed in the future.
    """
    partitionKey: Optional["CookiePartitionKey"]
    """
    Cookie partition key.
    """
    partitionKeyOpaque: Optional[bool]
    """
    True if cookie partition key is opaque.
    """


class SetCookieBlockedReason(str, Enum):
    """
    Types of reasons why a cookie may not be stored from a response.
    """

    SecureOnly = "SecureOnly"
    SameSiteStrict = "SameSiteStrict"
    SameSiteLax = "SameSiteLax"
    SameSiteUnspecifiedTreatedAsLax = "SameSiteUnspecifiedTreatedAsLax"
    SameSiteNoneInsecure = "SameSiteNoneInsecure"
    UserPreferences = "UserPreferences"
    ThirdPartyPhaseout = "ThirdPartyPhaseout"
    ThirdPartyBlockedInFirstPartySet = "ThirdPartyBlockedInFirstPartySet"
    SyntaxError = "SyntaxError"
    SchemeNotSupported = "SchemeNotSupported"
    OverwriteSecure = "OverwriteSecure"
    InvalidDomain = "InvalidDomain"
    InvalidPrefix = "InvalidPrefix"
    UnknownError = "UnknownError"
    SchemefulSameSiteStrict = "SchemefulSameSiteStrict"
    SchemefulSameSiteLax = "SchemefulSameSiteLax"
    SchemefulSameSiteUnspecifiedTreatedAsLax = (
        "SchemefulSameSiteUnspecifiedTreatedAsLax"
    )
    SamePartyFromCrossPartyContext = "SamePartyFromCrossPartyContext"
    SamePartyConflictsWithOtherAttributes = "SamePartyConflictsWithOtherAttributes"
    NameValuePairExceedsMaxSize = "NameValuePairExceedsMaxSize"
    DisallowedCharacter = "DisallowedCharacter"
    NoCookieContent = "NoCookieContent"


class CookieBlockedReason(str, Enum):
    """
    Types of reasons why a cookie may not be sent with a request.
    """

    SecureOnly = "SecureOnly"
    NotOnPath = "NotOnPath"
    DomainMismatch = "DomainMismatch"
    SameSiteStrict = "SameSiteStrict"
    SameSiteLax = "SameSiteLax"
    SameSiteUnspecifiedTreatedAsLax = "SameSiteUnspecifiedTreatedAsLax"
    SameSiteNoneInsecure = "SameSiteNoneInsecure"
    UserPreferences = "UserPreferences"
    ThirdPartyPhaseout = "ThirdPartyPhaseout"
    ThirdPartyBlockedInFirstPartySet = "ThirdPartyBlockedInFirstPartySet"
    UnknownError = "UnknownError"
    SchemefulSameSiteStrict = "SchemefulSameSiteStrict"
    SchemefulSameSiteLax = "SchemefulSameSiteLax"
    SchemefulSameSiteUnspecifiedTreatedAsLax = (
        "SchemefulSameSiteUnspecifiedTreatedAsLax"
    )
    SamePartyFromCrossPartyContext = "SamePartyFromCrossPartyContext"
    NameValuePairExceedsMaxSize = "NameValuePairExceedsMaxSize"


class CookieExemptionReason(str, Enum):
    """
    Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the request.
    """

    NONE = "None"
    UserSetting = "UserSetting"
    TPCDMetadata = "TPCDMetadata"
    TPCDDeprecationTrial = "TPCDDeprecationTrial"
    TPCDHeuristics = "TPCDHeuristics"
    EnterprisePolicy = "EnterprisePolicy"
    StorageAccess = "StorageAccess"
    TopLevelStorageAccess = "TopLevelStorageAccess"
    CorsOptIn = "CorsOptIn"
    Scheme = "Scheme"


class BlockedSetCookieWithReason(BaseModel):
    """
    A cookie which was not stored from a response with the corresponding reason.
    """

    blockedReasons: list
    """
    The reason(s) this cookie was blocked.
    """
    cookieLine: str
    """
    The string representing this individual cookie as it would appear in the header.
This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
    """
    cookie: Optional["Cookie"]
    """
    The cookie object which represents the cookie which was not stored. It is optional because
sometimes complete cookie information is not available, such as in the case of parsing
errors.
    """


class ExemptedSetCookieWithReason(BaseModel):
    """
        A cookie should have been blocked by 3PCD but is exempted and stored from a response with the
    corresponding reason. A cookie could only have at most one exemption reason.
    """

    exemptionReason: "CookieExemptionReason"
    """
    The reason the cookie was exempted.
    """
    cookieLine: str
    """
    The string representing this individual cookie as it would appear in the header.
    """
    cookie: "Cookie"
    """
    The cookie object representing the cookie.
    """


class AssociatedCookie(BaseModel):
    """
        A cookie associated with the request which may or may not be sent with it.
    Includes the cookies itself and reasons for blocking or exemption.
    """

    cookie: "Cookie"
    """
    The cookie object representing the cookie which was not sent.
    """
    blockedReasons: list
    """
    The reason(s) the cookie was blocked. If empty means the cookie is included.
    """
    exemptionReason: Optional["CookieExemptionReason"]
    """
    The reason the cookie should have been blocked by 3PCD but is exempted. A cookie could
only have at most one exemption reason.
    """


class CookieParam(BaseModel):
    """
    Cookie parameter object
    """

    name: str
    """
    Cookie name.
    """
    value: str
    """
    Cookie value.
    """
    url: Optional[str]
    """
    The request-URI to associate with the setting of the cookie. This value can affect the
default domain, path, source port, and source scheme values of the created cookie.
    """
    domain: Optional[str]
    """
    Cookie domain.
    """
    path: Optional[str]
    """
    Cookie path.
    """
    secure: Optional[bool]
    """
    True if cookie is secure.
    """
    httpOnly: Optional[bool]
    """
    True if cookie is http-only.
    """
    sameSite: Optional["CookieSameSite"]
    """
    Cookie SameSite type.
    """
    expires: Optional["TimeSinceEpoch"]
    """
    Cookie expiration date, session cookie if not set
    """
    priority: Optional["CookiePriority"]
    """
    Cookie Priority.
    """
    sameParty: Optional[bool]
    """
    True if cookie is SameParty.
    """
    sourceScheme: Optional["CookieSourceScheme"]
    """
    Cookie source scheme type.
    """
    sourcePort: Optional[Union[float, int]]
    """
    Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
This is a temporary ability and it will be removed in the future.
    """
    partitionKey: Optional["CookiePartitionKey"]
    """
    Cookie partition key. If not set, the cookie will be set as not partitioned.
    """


class AuthChallenge(BaseModel):
    """
    Authorization challenge for HTTP status code 401 or 407.
    """

    source: Optional[Literal["Server", "Proxy"]]
    """
    Source of the authentication challenge.
    """
    origin: str
    """
    Origin of the challenger.
    """
    scheme: str
    """
    The authentication scheme used, such as basic or digest
    """
    realm: str
    """
    The realm of the challenge. May be empty.
    """


class AuthChallengeResponse(BaseModel):
    """
    Response to an AuthChallenge.
    """

    response: Literal["Default", "CancelAuth", "ProvideCredentials"]
    """
    The decision on what to do in response to the authorization challenge.  Default means
deferring to the default behavior of the net stack, which will likely either the Cancel
authentication or display a popup dialog box.
    """
    username: Optional[str]
    """
    The username to provide, possibly empty. Should only be set if response is
ProvideCredentials.
    """
    password: Optional[str]
    """
    The password to provide, possibly empty. Should only be set if response is
ProvideCredentials.
    """


class InterceptionStage(str, Enum):
    """
        Stages of the interception to begin intercepting. Request will intercept before the request is
    sent. Response will intercept after the response is received.
    """

    Request = "Request"
    HeadersReceived = "HeadersReceived"


class RequestPattern(BaseModel):
    """
    Request pattern for interception.
    """

    urlPattern: Optional[str]
    """
    Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
backslash. Omitting is equivalent to `"*"`.
    """
    resourceType: Optional["ResourceType"]
    """
    If set, only requests for matching resource types will be intercepted.
    """
    interceptionStage: Optional["InterceptionStage"]
    """
    Stage at which to begin intercepting requests. Default is Request.
    """


class SignedExchangeSignature(BaseModel):
    """
        Information about a signed exchange signature.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    """

    label: str
    """
    Signed exchange signature label.
    """
    signature: str
    """
    The hex string of signed exchange signature.
    """
    integrity: str
    """
    Signed exchange signature integrity.
    """
    certUrl: Optional[str]
    """
    Signed exchange signature cert Url.
    """
    certSha256: Optional[str]
    """
    The hex string of signed exchange signature cert sha256.
    """
    validityUrl: str
    """
    Signed exchange signature validity Url.
    """
    date: Union[float, int]
    """
    Signed exchange signature date.
    """
    expires: Union[float, int]
    """
    Signed exchange signature expires.
    """
    certificates: Optional[list]
    """
    The encoded certificates.
    """


class SignedExchangeHeader(BaseModel):
    """
        Information about a signed exchange header.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    """

    requestUrl: str
    """
    Signed exchange request URL.
    """
    responseCode: Union[float, int]
    """
    Signed exchange response code.
    """
    responseHeaders: "Headers"
    """
    Signed exchange response headers.
    """
    signatures: list
    """
    Signed exchange response signature.
    """
    headerIntegrity: str
    """
    Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
    """


class SignedExchangeErrorField(str, Enum):
    """
    Field type for a signed exchange related error.
    """

    signatureSig = "signatureSig"
    signatureIntegrity = "signatureIntegrity"
    signatureCertUrl = "signatureCertUrl"
    signatureCertSha256 = "signatureCertSha256"
    signatureValidityUrl = "signatureValidityUrl"
    signatureTimestamps = "signatureTimestamps"


class SignedExchangeError(BaseModel):
    """
    Information about a signed exchange response.
    """

    message: str
    """
    Error message.
    """
    signatureIndex: Optional[Union[float, int]]
    """
    The index of the signature which caused the error.
    """
    errorField: Optional["SignedExchangeErrorField"]
    """
    The field which caused the error.
    """


class SignedExchangeInfo(BaseModel):
    """
    Information about a signed exchange response.
    """

    outerResponse: "Response"
    """
    The outer response of signed HTTP exchange which was received from network.
    """
    header: Optional["SignedExchangeHeader"]
    """
    Information about the signed exchange header.
    """
    securityDetails: Optional["SecurityDetails"]
    """
    Security details for the signed exchange header.
    """
    errors: Optional[list]
    """
    Errors occurred while handling the signed exchange.
    """


class ContentEncoding(str, Enum):
    """
    List of content encodings supported by the backend.
    """

    deflate = "deflate"
    gzip = "gzip"
    br = "br"
    zstd = "zstd"


class PrivateNetworkRequestPolicy(str, Enum):
    Allow = "Allow"
    BlockFromInsecureToMorePrivate = "BlockFromInsecureToMorePrivate"
    WarnFromInsecureToMorePrivate = "WarnFromInsecureToMorePrivate"
    PreflightBlock = "PreflightBlock"
    PreflightWarn = "PreflightWarn"


class IPAddressSpace(str, Enum):
    Local = "Local"
    Private = "Private"
    Public = "Public"
    Unknown = "Unknown"


class ConnectTiming(BaseModel):
    requestTime: Union[float, int]
    """
    Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for
the same request (but not for redirected requests).
    """


class ClientSecurityState(BaseModel):
    initiatorIsSecureContext: bool
    initiatorIPAddressSpace: "IPAddressSpace"
    privateNetworkRequestPolicy: "PrivateNetworkRequestPolicy"


class CrossOriginOpenerPolicyValue(str, Enum):
    SameOrigin = "SameOrigin"
    SameOriginAllowPopups = "SameOriginAllowPopups"
    RestrictProperties = "RestrictProperties"
    UnsafeNone = "UnsafeNone"
    SameOriginPlusCoep = "SameOriginPlusCoep"
    RestrictPropertiesPlusCoep = "RestrictPropertiesPlusCoep"


class CrossOriginOpenerPolicyStatus(BaseModel):
    value: "CrossOriginOpenerPolicyValue"
    reportOnlyValue: "CrossOriginOpenerPolicyValue"
    reportingEndpoint: Optional[str]
    reportOnlyReportingEndpoint: Optional[str]


class CrossOriginEmbedderPolicyValue(str, Enum):
    NONE = "None"
    Credentialless = "Credentialless"
    RequireCorp = "RequireCorp"


class CrossOriginEmbedderPolicyStatus(BaseModel):
    value: "CrossOriginEmbedderPolicyValue"
    reportOnlyValue: "CrossOriginEmbedderPolicyValue"
    reportingEndpoint: Optional[str]
    reportOnlyReportingEndpoint: Optional[str]


class ContentSecurityPolicySource(str, Enum):
    HTTP = "HTTP"
    Meta = "Meta"


class ContentSecurityPolicyStatus(BaseModel):
    effectiveDirectives: str
    isEnforced: bool
    source: "ContentSecurityPolicySource"


class SecurityIsolationStatus(BaseModel):
    coop: Optional["CrossOriginOpenerPolicyStatus"]
    coep: Optional["CrossOriginEmbedderPolicyStatus"]
    csp: Optional[list]


class ReportStatus(str, Enum):
    """
    The status of a Reporting API report.
    """

    Queued = "Queued"
    Pending = "Pending"
    MarkedForRemoval = "MarkedForRemoval"
    Success = "Success"


ReportId = TypeVar("ReportId", bound=str)


class ReportingApiReport(BaseModel):
    """
    An object representing a report generated by the Reporting API.
    """

    id: "ReportId"
    initiatorUrl: str
    """
    The URL of the document that triggered the report.
    """
    destination: str
    """
    The name of the endpoint group that should be used to deliver the report.
    """
    type: str
    """
    The type of the report (specifies the set of data that is contained in the report body).
    """
    timestamp: network.TimeSinceEpoch
    """
    When the report was generated.
    """
    depth: Union[float, int]
    """
    How many uploads deep the related request was.
    """
    completedAttempts: Union[float, int]
    """
    The number of delivery attempts made so far, not including an active attempt.
    """
    body: dict
    status: "ReportStatus"


class ReportingApiEndpoint(BaseModel):
    url: str
    """
    The URL of the endpoint to which reports may be delivered.
    """
    groupName: str
    """
    Name of the endpoint group.
    """


class LoadNetworkResourcePageResult(BaseModel):
    """
    An object providing the result of a network resource load.
    """

    success: bool
    netError: Optional[Union[float, int]]
    """
    Optional values used for error reporting.
    """
    netErrorName: Optional[str]
    httpStatusCode: Optional[Union[float, int]]
    stream: Optional[io.StreamHandle]
    """
    If successful, one of the following two fields holds the result.
    """
    headers: Optional[network.Headers]
    """
    Response headers.
    """


class LoadNetworkResourceOptions(BaseModel):
    """
        An options object that may be extended later to better support CORS,
    CORB and streaming.
    """

    disableCache: bool
    includeCredentials: bool
